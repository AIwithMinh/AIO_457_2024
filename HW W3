#Bài 1 
import torch
import torch . nn as nn
data = torch . Tensor ([1 , 2 , 3])
softmax_function = nn . Softmax ( dim =0)
output = softmax_function ( data )
#assert round ( output [0]. item () , 2) == 0.09
round ( output [1]. item () , 4)
output
#Bài 2 
import torch
import torch . nn as nn
class MySoftmax ( nn . Module ) :
    def __init__ ( self ):
        super () . __init__ ()
    def forward(self, x):
        exp_x = torch.exp(x)  
        softmax_x = exp_x / exp_x.sum()  
        return softmax_x
data = torch . Tensor ([5 , 2 , 4])
my_softmax = MySoftmax ()
output = my_softmax ( data )
#assert round ( output [ -1]. item () ,2) == 0.26

output
#Bài 3 
import torch
import torch . nn as nn
class MySoftmax ( nn . Module ) :
    def __init__ ( self ) :
        super () . __init__ ()
    def forward ( self , x ) :
        exp_x = torch.exp ( x )
        softmax_x = exp_x / exp_x.sum ()
        return softmax_x
data = torch.Tensor ([1 , 2 , 300000000])
my_softmax = MySoftmax ()
output = my_softmax ( data )
#assert round ( output [0]. item () , 2) == 0.0
output
#Bài 4
import torch
import torch . nn as nn
class SoftmaxStable ( nn . Module ):
  def __init__ ( self ) :
     super () . __init__ ()
  def forward ( self , x ) :
    x_max = torch .max(x , dim =0 , keepdims = True )
    x_exp = torch . exp ( x - x_max . values )
    partition = x_exp .sum (0 , keepdims = True )
    return x_exp / partition
data = torch . Tensor ([1 , 2 , 3])
softmax_stable = SoftmaxStable ()
output = softmax_stable ( data )
#assert round ( output [ -1]. item () , 2) == 0.67
output
# Bài 5 
from abc import ABC, abstractmethod

class Person(ABC):
    def __init__(self, name: str, yob: int):
        self._name = name
        self._yob = yob

    def get_yob(self):
        return self._yob

    @abstractmethod
    def describe(self):
        pass

class Student(Person):
    def __init__(self, name: str, yob: int, grade: str):
        super().__init__(name, yob)
        self._grade = grade

    def describe(self):
        print(f"Student Name: {self._name}, Year of Birth: {self._yob}, Grade: {self._grade}")

student1 = Student(name="studentZ2023", yob=2011, grade="6")
#assert student1._yob == 2011
student1.describe()
# Bài 6 
from abc import ABC, abstractmethod

class Person(ABC):
    def __init__(self, name: str, yob: int):
        self._name = name
        self._yob = yob

    def get_yob(self):
        return self._yob

    @abstractmethod
    def describe(self):
        pass

class Teacher(Person):
    def __init__(self, name: str, yob: int, subject: str):
        super().__init__(name, yob)  # Gọi __init__ của lớp cha Person
        self._subject = subject

    def describe(self):
        print(f"Teacher Name: {self._name}, Year of Birth: {self._yob}, Subject: {self._subject}")

teacher1 = Teacher(name="teacherZ2023", yob=1991, subject="History")
assert teacher1._yob == 1991
teacher1.describe()
#bài 7 
from abc import ABC, abstractmethod

class Person(ABC):
    def __init__(self, name: str, yob: int):
        self._name = name
        self._yob = yob

    def get_yob(self):
        return self._yob

    @abstractmethod
    def describe(self):
        pass

class Doctor (Person):
    def __init__(self, name: str, yob: int, specialist: str):
        super().__init__(name, yob)  # Gọi __init__ của lớp cha Person
        self._specialist = specialist

    def describe(self):
        print(f"Doctor - Name: {self._name}, yob: {self._yob}, specialist: {self._specialist}")

Doctor1 = Doctor(name="doctorZ2023", yob=1981, specialist="endocrinologists")
assert Doctor1._yob == 1981
Doctor1.describe()
#Bài 8 
from abc import ABC, abstractmethod

class Person(ABC):
    def __init__(self, name: str, yob: int):
        self._name = name
        self._yob = yob

    def get_yob(self):
        return self._yob

    @abstractmethod
    def describe(self):
        pass

class Student(Person):
    def __init__(self, name: str, yob: int, grade: str):
        super().__init__(name, yob)
        self._grade = grade

    def describe(self):
        print(f"Student Name: {self._name}, Year of Birth: {self._yob}, Grade: {self._grade}")

class Teacher(Person):
    def __init__(self, name: str, yob: int, subject: str):
        super().__init__(name, yob)
        self._subject = subject

    def describe(self):
        print(f"Teacher Name: {self._name}, Year of Birth: {self._yob}, Subject: {self._subject}")

class Doctor(Person):
    def __init__(self, name: str, yob: int, specialist: str):
        super().__init__(name, yob)
        self._specialist = specialist

    def describe(self):
        print(f"Doctor Name: {self._name}, Year of Birth: {self._yob}, Specialist: {self._specialist}")

class Ward:
    def __init__(self, name: str):
        self.__name = name
        self.__listPeople = list()

    def add_person(self, person: Person):
        self.__listPeople.append(person)

    def describe(self):
        print(f"Ward Name: {self.__name}")
        for p in self.__listPeople:
            p.describe()

    def count_doctor(self):
        return sum(1 for person in self.__listPeople if isinstance(person, Doctor))
student1 = Student(name="studentA", yob=2010, grade="7")
teacher1 = Teacher(name="teacherA", yob=1969, subject="Math")
teacher2 = Teacher(name="teacherB", yob=1995, subject="History")
doctor1 = Doctor(name="doctorA", yob=1945, specialist="Endocrinologists")
doctor2 = Doctor(name="doctorB", yob=1975, specialist="Cardiologists")
ward1 = Ward(name="Ward1")
ward1.add_person(student1)
ward1.add_person(teacher1)
ward1.add_person(teacher2)
ward1.add_person(doctor1)
ward1.add_person(doctor2)
'''
assert ward1.count_doctor() == 2'''
ward1.count_doctor()
#bÀI 9 
class MyStack :
   def __init__ ( self , capacity ) :
       self . __capacity = capacity
       self . __stack = []
   def is_full ( self ) :
       return len( self . __stack ) == self . __capacity
   def get_ipython ( self ) :
       return self . __stack
   def set_ipython ( self , value ) :
       self . __stack = value
   def push ( self , value ) :
       if self . is_full () :
           raise Exception ( "Stack is full" )
       else: 
           self . __stack . append ( value )

stack1 = MyStack ( capacity =5)
stack1 . push (1)
stack1 . push (2)
len(stack1. get_ipython()) == 2 
stack1. is_full()
#bài 10 
class MyStack:
    def __init__(self, capacity):
        self.__capacity = capacity
        self.__stack = []  
    def is_full(self):
        return len(self.__stack) == self.__capacity

    def push(self, value):
        if self.is_full():
            raise Exception("Stack is full")
        else:
            self.__stack.append(value)

    def top(self):
        if not self.__stack:
            raise Exception("Stack is empty")
        return self.__stack[-1]
stack1 = MyStack(capacity=5)
stack1.push(2)
stack1.push(3)
print(stack1.top()) 
# Bài 11 
class MyQueue:
    def __init__(self, capacity):
        self.__capacity = capacity
        self.__queue = []

    def is_full(self):
        return len(self.__queue) == self.__capacity

    def enqueue(self, value):
        if self.is_full():
            raise Exception("Queue is full")
        else:
            self.__queue.append(value)

queue1 = MyQueue(capacity=5)
queue1.enqueue(2)
print(queue1.is_full()) 
#Bài 12 
class MyQueue:
    def __init__(self, capacity):
        self.__capacity = capacity
        self.__queue = []

    def isEmpty(self):
        return len(self.__queue) == 0

    def is_full(self):
        return len(self.__queue) == self.__capacity

    def dequeue(self):
        if self.isEmpty():
            raise Exception("Queue is empty")
        else:
            return self.__queue.pop(0)

    def enqueue(self, value):
        if self.is_full():
            raise Exception("Queue is full")
        else:
            self.__queue.append(value)

    def front(self):
        if self.isEmpty():
            raise Exception("Queue is empty")
        else:
            return self.__queue[0]
            
queue1 = MyQueue(5)
queue1 . enqueue (2)
print(queue1.front())



